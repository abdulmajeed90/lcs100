为了适应存储空间少的限制，升级的方案采用在app中设置升级请求标志，在bootloader中根据是否有升级请求标志来完成升级操作。

8个扇区，每个扇区4k
扇区布局


bootloaer区：  8k [串口通讯,iap,flash，想办法压缩到8k]
app应用程序区  24k

第一种方案:
1.app中接收到控制器发来的升级请求后，比较升级文件大小和自生的升级区域大小，如果空间足够，则回应成功，并且在flash的最后一个区域设置升级请求标志。否则回应失败原因给控制器。
2.控制器收到成功回应后，发送复位设备请求给单灯模块。单灯设备复位。
3.控制器等待3s后，发送查询单灯工作模式命令，查询单灯是处于（boot模式，还是App模式），也就是查询是否已经复位成功。而单灯重新启动后，会检查升级请求标志，如果已经设置了标志，则监控串口数据n分钟，等待升级数据包。如果1分钟内都没有收到任何请求，则自动跳转到app模式【并且擦除升级请求标志】。如果没有升级标志，则自动进入app模式。
4.控制器查询到设备已经进入单灯模式后，发送升级数据包，单灯回应升级数据包。控制器设置超时时间，如果2s内都无回应，则超时重发该数据包，每个数据包都携带编号，以便单灯能够识别出重复的数据包。如果检测到还是app模式，就继续发送复位请求给单灯。

5.控制器发送完最后一包数据后，发送校验请求包，将文件的整体crc16校验数据，发送给单灯，单灯在计算升级文件的crc16数据，比较是否一致，如果一致，则回应成功，不一致则回应校验失败，校验成功后，控制器发送运行命令，单灯擦除升级请求标志，并且运行app程序。失败后，控制器重新发起升级包，直到升级校验通过为止。



第二种方案:
只使用升级请求包和升级数据包，升级校验包，复位包4种包

bootloaer在启动后，监听5s的串口数据，看是否有和自己id匹配的升级请求包，如果有就进入升级模式，检查升级数据是否过大，如果过大则返回错误原因，等待控制器下一步的操作。如果10s内都没有任何指示，则直接跳转到应用程序区。如果通过，则等待下一步的指示。
app收到升级请求包后，和bootloader一样，如果不允许，则回应失败原因，否则通知控制器可以升级，控制器下发复位命令，2s后不停发送升级请求命令，等待单灯进入boot模式后，接收升级请求。


这样最简单。
升级session:由控制器分配，每次升级事务有一个唯一的sessionID,为了防止其他模块的干扰。

升级请求包： 
终端ID[4] + 组ID[1] + 升级请求[1] + 升级session[2]+ 升级文件大小[4]
升级请求回应包:
终端ID[4] + 组ID[1] + 升级请求[1] + 回应码(成功或失败原因)[1] + 升级session[2]

升级数据包：
终端ID[4] + 组ID[1] + 数据包请求[1] + 升级session[2]+ 升级数据包序号[2] + 每包数据[1-每包最大字节数]
升级请求回应包:
终端ID[4] + 组ID[1] + 数据包请求[1] + 回应码 (成功或失败原因)[1] + 升级session[2]+升级数据包序号[2] 

升级校验包：控制器发完最后一包后，发送升级校验数据，对升级文件的CRC16校验
终端ID[4] + 组ID[1] + 校验请求[1] + 升级session[2]+ CRC16校验[2]
升级请求回应包: （发送该数据包后10s，无回应自动复位)
终端ID[4] + 组ID[1] + 校验请求[1] + 回应码(成功或失败原因)[1] + 升级session[2]

复位包： 控制器在收到校验失败或则成功后。需要发送
终端ID[4] + 组ID[1] + 复位请求
单灯无需回应







